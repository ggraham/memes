---
title: "Motif Enrichment Testing using AME"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Motif Enrichment Testing using AME}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
NOT_CRAN <- identical(tolower(Sys.getenv("NOT_CRAN")), "true")

eval_vignette <- NOT_CRAN & has_meme_install()

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  purl = eval_vignette,
  eval = eval_vignette
)
```

```{r setup}
library(dremeR)
suppressPackageStartupMessages(library(GenomicRanges))
library(magrittr)
```

## Sequence Input
AME requires a series of input sequences to scan for motif enrichment.
`runAme()` accepts sequence input in the following formats:

 - a `Biostrings::XStringSet` object
 - a named list of `Biostrings::XStringSet` objects
 - a path to a .fasta file
 
**NOTE** `XStringSet` inputs can be easily generated for DNA sequences from a
GRanges object using the `get_sequence()` function

```{r}
data("example_peaks", package = "dremeR")

dm.genome <- BSgenome.Dmelanogaster.UCSC.dm3::BSgenome.Dmelanogaster.UCSC.dm3

sequence <- example_peaks %>% 
  get_sequence(dm.genome)
```

## Database Input
AME scans input sequences against a database of known motifs and tests for
enrichment of each motif in the database. `runAme()` can accept a database in
the following formats:

 - a list of universalmotif objects
 - a single universalmotif object
 - the results object from `runDreme`
 - a path to a .meme format file

### Setting a default database 

dremeR can be configured to use a default .meme format file as the query
database, which it will use if the user does not provide a value to `database`
when calling `runAme()`. The following locations will be searched in order.

1. The `meme_db` option, defined using `options(meme_db = "path/to/database.meme")`
 - The `meme_db` option can also be set to an R object, like a universalmotif list.
2. The `MEME_DB` environment variable defined in `.Renviron`
 - The `MEME_DB` variable will only accept a path to a .meme file

**NOTE:** if an invalid location is found at one option, `runAme()` will fall
back to the next location if valid (eg if the `meme_db` option is set to an
invalid file, but the `MEME_DB` environment variable is a valid file, the
`MEME_DB` path will be used.

```{r}
options(meme_db = system.file("extdata/db/fly_factor_survey_id.meme", package = "dremeR"))
```

## Running AME

`runAme()` supports running AME using three modes:

| AME Mode          | Description                | Command                                         |
|:-----------------:|:--------------------------:|:------------------------------------------------|
| Vs Shuffled       | Input vs Shuffled Sequence | `runAme(input = sequence, control = "shuffle")` |
| Discriminative    | Input vs Control Sequence  | `runAme(input = sequence, control = control)`   |
| Partitioning      | Rank Input by fasta score  | `runAme(input = sequence, control = NA)`        |

```{r, eval=F}
ame_vs_shuffle <- runAme(sequence)
```

```{r, eval=F}
ame_vs_control <- runAme(sequence[1:5], sequence[6:10])
```


To run AME using partitioning mode, the fasta header must contain a score value
for each entry in the form: ">entry_name score". The `get_sequences()` `score`
argument allows users to set the score value to a column value from input
regions.

```{r}
sequence_scored <- example_peaks %>% 
  plyranges::mutate(score = seq_along(.)) %>% 
  get_sequence(dm.genome, score = "score")

names(sequence_scored)[1]
```
```{r, eval=F}
ame_partition <- runAme(sequence_scored, control = NA)
```

### Running AME on multiple groups

If using a list input to `runAme()`, it will dispatch multiple AME runs for each
object in the list.

```{r}
data("example_chip_summits", package = "dremeR")

seq_by_behavior <- example_chip_summits %>% 
  plyranges::mutate(width = 100) %>% 
  split(mcols(.)$e93_sensitive_behavior) %>% 
  get_sequence(dm.genome)
```
```{r, eval=F}
ame_by_behavior <- runAme(seq_by_behavior)
```

#### Discriminative analysis using list input

If the input to `runAme()` is a named list of `XStringSet` objects, `control`
can be set to one or more values from `names(input)` to use those regions as
background. It will skip running those regions as the input. The following code
will result in these comparisons:

1. Increasing vs Static
2. Decreasing vs Static
```{r}
ame_by_behavior_vs_static <- runAme(seq_by_behavior, control = "Static")
```

If multiple names are used in the `control` section, they will be combined
together to make a single control set which will be used for all comparisons.
Here, we use "Static" and "Decreasing" sites as the control, which will result
in only running 1 comparison: Increasing vs Static+Decreasing.
```{r, eval=F}
runAme(seq_by_behavior, control = c("Static", "Decreasing"))
```
```{r, echo=F}
data("example_ame", package = "dremeR")
ame_by_behavior_vs_static <- example_ame
```

## Output Format

AME will return different output formats depending on the `method` used. For
detailed information about these values see the [AME Output description
webpage](http://meme-suite.org/doc/ame-output-format.html). As a general rule of
thumb, `runAme()` will return the same column names described in the webpage,
except dashes are removed and all column names are lowercase.

```{r}
ame_by_behavior_vs_static$Decreasing %>% 
  names
```

If `runAme()` is run with `method = "fisher"`, the sequences output can be added
to the results by setting `sequences = TRUE`. This will be added as a list
column named `sequences` that can be unnested using `tidyr::unnest()`.

## Visualizing Results as Heatmap
 - move heatmap information here
 
```{r}
ame_by_behavior_vs_static %>% 
  # AME results in list format are easily combined using dplyr::bind_rows
  # .id will specify a column to hold the list object names
  dplyr::bind_rows(.id = "behavior") %>% 
  # setting group to a column name will split the results on the y-axis
  ame_plot_heatmap(group = behavior)
```

# NEW SECTION RE: HEATMAP complexity
moving this here because chip-seq example now integrates RNAseq filtering, so hits are more limited
```{r}
seq_by_binding <- example_chip_summits %>% 
  plyranges::mutate(width = 100) %>% 
  split(mcols(.)$peak_binding_description) %>% 
  get_sequence(dm.genome)
```

```{r, eval=F}
ame_by_binding <- seq_by_binding %>% 
  runAme
```
```{r, echo=F}
# Allows vignette to build on systems w/o functioning MEME suite
data("example_ame_large", package = "dremeR")
ame_by_binding <- example_ame_large
```

### Visualizing AME results 

The `ame_plot_heatmap()` function provides a quick way to visualize AME results.
It is built on top of `ggplot2`, so all `ggplot2` functions can be used to
further modify the plot.

By default, it uses the -log10(adjusted p-value) as the heat values. See the
documentation for additional notes on customization.
```{r, fig.height=3.5, fig.width=7}

ame_by_binding$entopic %>% 
  dplyr::filter(rank %in% 1:10) %>% 
  ame_plot_heatmap(group_name = "Entopic Sites")  +
    ggtitle("Top 10 AME Hits in Entopic Sites")
```

To plot results from multiple runs together, they must first be joined into 1
data frame. The `ame_by_binding` object is a list whose names correspond to the
E93 binding category. The list can be combined into a data.frame using
`dplyr::bind_rows`. Setting `.id = "binding_type` creates a new column
`binding_type` that contains the names from the `ame_by_binding` list. In this
way, the `ame_res` data.frame contains all AME results for each run, which can
be distinguished by the `binding_type` column.
```{r}
ame_res <- ame_by_binding %>% 
  dplyr::bind_rows(.id = "binding_type")
  
```

It is possible to aggregate results from multiple runs into a heatmap by setting
the `group` parameter in `ame_plot_heatmap()`.

This is too many hits to view in this vignette, but you can see that the heatmap
will plot motifs by their overlap across groups, where unique motifs are on the
left, and shared motifs are on the right.
```{r, fig.height=5,fig.width=15}
ame_res %>% 
  ame_plot_heatmap(group = binding_type)
```

### Reducing redundant motif hits
There is another key consideration for the above visualization and that is that
in the FlyFactorSurvey database we used, different TFs can have multiple motif
entries in the database which are all detected separately by AME. Here, when
returning the top 5 hits from each group, you can see, for example, that a motif
matching "Aef1" is reported 3 times within the top 5 hits of the ectopic sites
(A similar result can also be seen in the top 10 entopic hits heatmap above).
In this situation, it makes sense to summarize the data at the TF level, instead
of the motif level. **Note:** There may be exceptions to this if for example, a
TF has multiple DNA binding sequences it can recognize, in which case having
multiple hits may reflect a biological property of your sequences. You will have
to handle this on a case-by-case basis for interesting hits and different motif
databases. Here, we can see that at least for Aef1, the consensus sequences are
very similar.
```{r}
ame_res %>% 
  dplyr::group_by(binding_type) %>% 
  dplyr::filter(rank %in% 1:5) %>% 
  head(5) %>% 
  dplyr::select(binding_type, rank, motif_id, motif_alt_id, consensus)
```

How to solve this problem will vary with different motif databases (For details
on how to pre-process a motif database, see `vignette("tidy_motifs")`). In the
FlyFactorSurvey database, the `motif_alt_id` column contains a unique FBgn
number for each TF. For entries of the same TF, the FBgn number is prepended
with an `_<number>`. We can extract the FBgn number to use as a gene-level
identifier, and reduce the matches to return 1 match per gene as follows:
```{r, fig.height=3, fig.width=25}
ame_res %>% 
  # the flyfactor genes have their Flybase gene numbers appended with a _<number> 
  # this is to make the entries unique, but the gene ID is encoded before the _
  # so I remove the _<number> with a regex, leaving the FBgn number.
  dplyr::mutate(gene_id = gsub("_\\d+", "", motif_alt_id)) %>% 
  dplyr::ungroup() %>% 
  # Reduce redundant TF hits by returning only the match with the lowest p-value
  # for each TF. It is important to group by binding_type because the analyses
  # were run separately, so these are different results (we want to return the
  # lowest p-value for each group a motif was found within).
  dplyr::group_by(binding_type, gene_id) %>% 
  dplyr::filter(adj.pvalue == min(adj.pvalue)) %>% 
  # add new id column to simplify motif name to TF name
  dplyr::mutate(tfid = strsplit(motif_id, "_")[[1]][1]) %>% 
  ame_plot_heatmap(group = binding_type, id = tfid)
```


## Issues with AME Heatmap Visualization
Finally, because the data for each binding type are generated from different AME
runs, it is not the best idea to compare p-values across experiments (ie between
heatmap rows), because the dynamic range of p-values will vary between groups. Here you
can see that, for example, the orphan sites will have a very different scale of
-log10(adjusted pvalues) than ectopic and entopic sites. In other words, because
the dynamic range of values are different between experiments, placing them on
the same scale for comparison may be misleading in certain contexts.

```{r}
logpval_dist <- ame_res %>% 
  ggplot(aes(-log10(adj.pvalue))) +
    stat_ecdf(aes(color = binding_type), size = 1, pad = FALSE) +
    labs(y = "Fraction of Motifs") +
    theme_bw() +
    theme(legend.position = "none") +
    labs(title = "value = -log10(adj.pvalue)")
    
```

We can partially overcome this limitation by filling the heatmap with the
normalized rank value for each TF, which accounts for differences in total number of
discovered motifs between AME runs. Although it does not completely abrograte
differeces, the signal values for high-ranked motifs within groups will be more
comparable. However, **the normalized rank visualization eliminates all real values related to statistical significance!** 
Instead, this visualization represents the relative ranks of hits within an AME
run, which already pass a significance threshold set during `runAME()`. This
means that even if several motifs have similar or even identical pvalues, their
heatmap representation will be a different color value based on their ranked
order in the results list. Both visualizations can be useful and reveal different
properties of the data to the user. **If in doubt**, prefer the
`-log10(adj.pvalue)` representation.
```{r}
# rank_normalize transforms the ranks to values between 0 and 1 as follows:
# (1 - rank)/(1 - max(rank))
normrank_dist <- ame_res %>% 
  ggplot(aes(dremeR:::rank_normalize(rank))) +
    stat_ecdf(aes(color = binding_type), size = 1, pad = FALSE) +
    scale_x_continuous(
                       breaks = c(0, 0.25, 0.5, 0.75, 1),
                       labels = c("0\n(High)", 0.25, 0.5, 0.75, "1\n(Low)"),
                       ) +
    labs(title = "value = \"normalize\"",
         y = NULL,
         x = "Normalized Rank",
         color = "Binding Type")  +
    theme_bw() 
```

Below is a comparison of the distribution of values when using
`-log10(adj.pvalue)` (A) vs normalized ranks (B). Because orphan sites tend to
have smaller p-values overall, the heatmap scale will be skewed towards the high
values in the orphan data, making ectopic and entopic heat values lighter by
comparison.
```{r, fig.height=3, fig.width=7.5}
cowplot::plot_grid(logpval_dist,
                   normrank_dist,
                   rel_widths = c(1,1.25),
                   labels = "AUTO")
```

We achieve this by setting `value = "normalize"` in `ame_plot_heatmap()`. If
plotting with multiple groups, it may be more appropriate to make this
visualization.

This plot reveals that the motifs which tend to be shared across all 3
categories tend to be higher ranks in the output than the motifs unique to the
different categories, which tend to come from lower ranks. This *suggests* that
although there are differences in motif content across the three categories,
they may be largely similar in motif makeup. We will investigate this question
in more detail in the "Denovo motif similarity" section.
```{r, fig.height=3, fig.width=25}
ame_res %>% 
  dplyr::mutate(gene_id = gsub("_\\d+", "", motif_alt_id)) %>% 
  dplyr::ungroup() %>% 
  dplyr::group_by(binding_type, gene_id) %>% 
  dplyr::filter(adj.pvalue == min(adj.pvalue)) %>% 
  dplyr::mutate(tfid = strsplit(motif_id, "_")[[1]][1]) %>% 
  ame_plot_heatmap(group = binding_type, id = tfid, value = "normalize")
```

 

## Importing Previous Data

`importAme()` can be used to import an `ame.tsv` file from a previous run
on the MEME server or on the commandline. Details for how to save data from the
AME webserver are below.

Optionally, if AME was run on the commandline with `--method fisher`, the user
can pass a path to the `sequences.tsv` file to the `sequences` argument of
`importAme()` to append the sequence information to the AME results.

### Saving data from AME Web Server
To download TSV data from the MEME Server, right-click the AME TSV output link
and "Save Target As" or "Save Link As" (see example image below), and save as
`<filename>.tsv`. This file can be read using `importAme()`. 

![saving AME tsv results](save_ame.png)

# Citation

dremeR is a wrapper for a select few tools from the MEME Suite, which were
developed by another group. In addition to citing dremeR, please cite the MEME
Suite tools corresponding to the tools you use.

If you use `runAme()` in your analysis, please cite:

Robert McLeay and Timothy L. Bailey, "Motif Enrichment Analysis: A unified framework and method evaluation", BMC Bioinformatics, 11:165, 2010, doi:10.1186/1471-2105-11-165. [full text](http://www.biomedcentral.com/1471-2105/11/165)

## Licensing Restrictions
The MEME Suite is free for non-profit use, but for-profit users should purchase a
license. See the [MEME Suite Copyright Page](http://meme-suite.org/doc/copyright.html) for details.
