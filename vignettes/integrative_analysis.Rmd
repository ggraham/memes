---
title: "Integrative Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Integrative Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dremeR)
library(magrittr)
suppressPackageStartupMessages(library(GenomicRanges))
```

```{r}
check_meme_install()
```


```{r, message=F}
peaks <- system.file("extdata/peaks/e93_chr3.csv", package = "dremeR") %>% 
  readr::read_csv() %>% 
  GRanges
```

### Motifs in opening vs closing sites
```{r}
# These data use the dm3 reference genome
dm.genome <- BSgenome.Dmelanogaster.UCSC.dm3::BSgenome.Dmelanogaster.UCSC.dm3

# compute summits using the summit_position column
summits <- peaks %>% 
  plyranges::anchor_start() %>% 
  plyranges::mutate(width = 1) %>% 
  plyranges::shift_right(mcols(.)$summit_position) 
  
# Get sequences in a 100bp window around the peak summit
summit_flank <- summits %>% 
  plyranges::anchor_center() %>% 
  plyranges::mutate(width = 100) 

# split by response to E93 binding
by_sens <- summit_flank %>% 
  split(mcols(.)$e93_sensitive_behavior) %>% 
  get_sequence(dm.genome)
```

```{r dreme_by_sens_vs_static, eval=F}
dreme_by_sens_vs_static <- runDreme(by_sens, "Static")
```
```{r, echo=F}
data("example_dreme_by_sens_vs_static", package = "dremeR")
dreme_by_sens_vs_static <- example_dreme_by_sens_vs_static
```

```{r}
dreme_results <- dreme_by_sens_vs_static %>% 
  dplyr::bind_rows(.id = "e93_response")
```
```{r}
#options(meme_db = )
options(meme_db = "../inst/extdata/db/fly_factor_survey_id.meme")
all_res <- dreme_results %>% 
  runTomTom(dist = "ed")
```

```{r, fig.height=8, fig.width=8}
all_res %>% 
  view_tomtom_hits(3) %>% 
  cowplot::plot_grid(plotlist = ., labels = "AUTO")
```
```{r}
all_res %<>% 
  force_best_match(c("m01_CSAAAAM" = "Eip93F_SANGER_10",
                     "m03_AKGG" = "pho_SANGER_10"))
```


```{r, fig.height=4.5, fig.width=8}
all_res %>% 
  view_tomtom_hits(1) %>% 
  cowplot::plot_grid(plotlist = ., labels = "AUTO")
```

```{r, fig.height=3, fig.width=8}
all_res %>% 
  dplyr::mutate(label = paste0(e93_response, " in response to E93")) %>% 
  split(.$label) %>% 
  purrr::imap(~{
    top_hits <- view_tomtom_hits(.x, 1) %>% 
      cowplot::plot_grid(plotlist = ., nrow = 1, labels = "AUTO")
    
    title <- cowplot::ggdraw() +
        cowplot::draw_text(.y)
    
    cowplot::plot_grid(plotlist = list(title, top_hits), 
                       ncol = 1,
                       rel_heights = c(0.1, 1)
    )
  })
```

### Motif scanning with AME
```{r}
by_binding <- summit_flank %>% 
  split(mcols(.)$peak_binding_description) %>% 
  get_sequence(dm.genome)
```

```{r, eval=F}
ame_by_binding <- by_binding %>% 
  runAme
```
```{r, echo=F}
# Allows vignette to build on systems w/o functioning MEME suite
data("example_ame_large", package = "dremeR")
ame_by_binding <- example_ame_large
```

### Visualizing AME results

The `ame_plot_heatmap()` function provides a quick way to visualize AME results.
It is built on top of `ggplot2`, so all `ggplot2` functions can be used to
further modify the plot.

By default, it uses the -log10(adjusted p-value) as the heat values. See the
documentation for additional notes on customization.
```{r, fig.height=3.5, fig.width=7}
library(ggplot2)

ame_by_binding$entopic %>% 
  dplyr::filter(rank %in% 1:10) %>% 
  ame_plot_heatmap(group_name = "Entopic Sites")  +
    ggtitle("Top 10 AME Hits in Entopic Sites")
```

To plot results from multiple runs together, they must first be joined into 1
data frame. The `ame_by_binding` object is a list whose names correspond to the
E93 binding category. The list can be combined into a data.frame using
`dplyr::bind_rows`. Setting `.id = "binding_type` creates a new column
`binding_type` that contains the names from the `ame_by_binding` list. In this
way, the `ame_res` data.frame contains all AME results for each run, which can
be distinguished by the `binding_type` column.
```{r}
ame_res <- ame_by_binding %>% 
  dplyr::bind_rows(.id = "binding_type")
  
```

It is possible to aggregate results from multiple runs into a heatmap by setting
the `group` parameter in `ame_plot_heatmap()`.

This is too many hits to view in this vignette, but you can see that the heatmap
will plot motifs by their overlap across groups, where unique motifs are on the
left, and shared motifs are on the right.
```{r, fig.height=5,fig.width=15}
ame_res %>% 
  ame_plot_heatmap(group = binding_type)
```

### Reducing redundant motif hits
There is another key consideration for the above visualization and that is that
in the FlyFactorSurvey database we used, different TFs can have multiple motif
entries in the database which are all detected separately by AME. Here, when
returning the top 5 hits from each group, you can see, for example, that a motif
matching "Aef1" is reported 3 times within the top 5 hits of the ectopic sites
(A similar result can also be seen in the top 10 entopic hits heatmap above).
In this situation, it makes sense to summarize the data at the TF level, instead
of the motif level. **Note:** There may be exceptions to this if for example, a
TF has multiple DNA binding sequences it can recognize, in which case having
multiple hits may reflect a biological property of your sequences. You will have
to handle this on a case-by-case basis for interesting hits and different motif
databases. Here, we can see that at least for Aef1, the consensus sequences are
very similar.
```{r}
ame_res %>% 
  dplyr::group_by(binding_type) %>% 
  dplyr::filter(rank %in% 1:5) %>% 
  head(5) %>% 
  dplyr::select(binding_type, rank, motif_id, motif_alt_id, consensus)
```

How to solve this problem will vary with different motif databases (For details
on how to pre-process a motif database, see `vignette("tidy_motifs")`). In the
FlyFactorSurvey database, the `motif_alt_id` column contains a unique FBgn
number for each TF. For entries of the same TF, the FBgn number is prepended
with an `_<number>`. We can extract the FBgn number to use as a gene-level
identifier, and reduce the matches to return 1 match per gene as follows:
```{r, fig.height=3, fig.width=25}
ame_res %>% 
  # the flyfactor genes have their Flybase gene numbers appended with a _<number> 
  # this is to make the entries unique, but the gene ID is encoded before the _
  # so I remove the _<number> with a regex, leaving the FBgn number.
  dplyr::mutate(gene_id = gsub("_\\d+", "", motif_alt_id)) %>% 
  dplyr::ungroup() %>% 
  # Reduce redundant TF hits by returning only the match with the lowest p-value
  # for each TF. It is important to group by binding_type because the analyses
  # were run separately, so these are different results (we want to return the
  # lowest p-value for each group a motif was found within).
  dplyr::group_by(binding_type, gene_id) %>% 
  dplyr::filter(adj.pvalue == min(adj.pvalue)) %>% 
  # add new id column to simplify motif name to TF name
  dplyr::mutate(tfid = strsplit(motif_id, "_")[[1]][1]) %>% 
  ame_plot_heatmap(group = binding_type, id = tfid)
```


## Issues with AME Heatmap Visualization
Finally, because the data for each binding type are generated from different AME
runs, it is not the best idea to compare p-values across experiments (ie between
heatmap rows), because the dynamic range of p-values will vary between groups. Here you
can see that, for example, the orphan sites will have a very different scale of
-log10(adjusted pvalues) than ectopic and entopic sites. In other words, because
the dynamic range of values are different between experiments, placing them on
the same scale for comparison may be misleading in certain contexts.

```{r}
logpval_dist <- ame_res %>% 
  ggplot(aes(-log10(adj.pvalue))) +
    stat_ecdf(aes(color = binding_type), size = 1, pad = FALSE) +
    labs(y = "Fraction of Motifs") +
    theme_bw() +
    theme(legend.position = "none") +
    labs(title = "value = -log10(adj.pvalue)")
    
```

We can partially overcome this limitation by filling the heatmap with the
normalized rank value for each TF, which accounts for differences in total number of
discovered motifs between AME runs. Although it does not completely abrograte
differeces, the signal values for high-ranked motifs within groups will be more
comparable. However, **the normalized rank visualization eliminates all real values related to statistical significance!** 
Instead, this visualization represents the relative ranks of hits within an AME
run, which already pass a significance threshold set during `runAME()`. This
means that even if several motifs have similar or even identical pvalues, their
heatmap representation will be a different color value based on their ranked
order in the results list. Both visualizations can be useful and reveal different
properties of the data to the user. **If in doubt**, prefer the
`-log10(adj.pvalue)` representation.
```{r}
# rank_normalize transforms the ranks to values between 0 and 1 as follows:
# (1 - rank)/(1 - max(rank))
normrank_dist <- ame_res %>% 
  ggplot(aes(dremeR:::rank_normalize(rank))) +
    stat_ecdf(aes(color = binding_type), size = 1, pad = FALSE) +
    scale_x_continuous(
                       breaks = c(0, 0.25, 0.5, 0.75, 1),
                       labels = c("0\n(High)", 0.25, 0.5, 0.75, "1\n(Low)"),
                       ) +
    labs(title = "value = \"normalize\"",
         y = NULL,
         x = "Normalized Rank",
         color = "Binding Type")  +
    theme_bw() 
```

Below is a comparison of the distribution of values when using
`-log10(adj.pvalue)` (A) vs normalized ranks (B). Because orphan sites tend to
have smaller p-values overall, the heatmap scale will be skewed towards the high
values in the orphan data, making ectopic and entopic heat values lighter by
comparison.
```{r, fig.height=3, fig.width=7.5}
cowplot::plot_grid(logpval_dist,
                   normrank_dist,
                   rel_widths = c(1,1.25),
                   labels = "AUTO")
```

We achieve this by setting `value = "normalize"` in `ame_plot_heatmap()`. If
plotting with multiple groups, it may be more appropriate to make this
visualization.

This plot reveals that the motifs which tend to be shared across all 3
categories tend to be higher ranks in the output than the motifs unique to the
different categories, which tend to come from lower ranks. This *suggests* that
although there are differences in motif content across the three categories,
they may be largely similar in motif makeup. We will investigate this question
in more detail in the "Denovo motif similarity" section.
```{r, fig.height=3, fig.width=25}
ame_res %>% 
  dplyr::mutate(gene_id = gsub("_\\d+", "", motif_alt_id)) %>% 
  dplyr::ungroup() %>% 
  dplyr::group_by(binding_type, gene_id) %>% 
  dplyr::filter(adj.pvalue == min(adj.pvalue)) %>% 
  dplyr::mutate(tfid = strsplit(motif_id, "_")[[1]][1]) %>% 
  ame_plot_heatmap(group = binding_type, id = tfid, value = "normalize")
```


## FIMO 
Because we discover a *de-novo* motif from DREME that matches to E93, it can be useful to scan peaks for motif occurrances to further examine properties of different peak categories.

Although we could also import the motifs from our local .meme database file, it is also possible to use motifs pulled from a [`MotifDb`](https://bioconductor.org/packages/release/bioc/html/MotifDb.html) query as follows. 
```{r}
e93_motif <- MotifDb::MotifDb %>% 
  # Query the database for the E93 motif using it's gene name
  MotifDb::query("Eip93F") %>% 
  # Convert from motifdb format to universalmotif format
  universalmotif::convert_motifs() %>% 
  # The result is a list, to simplify the object, return it as a single universalmotif
  .[[1]]

# Rename the motif from it's flybase gene number to a more user-friendly name
e93_motif["name"] <- "E93"

e93_motif
```

Just like `runDreme()` and `runAme()`, `runFimo()` takes a
`Biostrings::XStringSet` as input. Using `get_sequence()` to generate these for
DNA sequences is preferred because it creates sequence inputs that can be parsed
into genomic coordinates by Fimo.
```{r}
fimo_res <- summit_flank %>% 
  get_sequence(dm.genome) %>% 
  runFimo(motifs = e93_motif, thresh = 1e-3)
```

The results of `runFimo()` are returned as a `GRanges` object containing the
positions of each motif discovered in the input sequences. The best way to
integrate these data with our input peaks is to use the `plyranges` suite of
tools for performing overlaps and joins between `GRanges` objects.
```{r}
fimo_res
```

### Counting the number of motifs per peak

`plyranges` extends `dplyr`-like syntax to range objects. Here we add a count
for each motif per peak in the `n_motifs` column. We also add a column
`has_motif` which will be a binary indicator of whether a peak contains any
motifs.
```{r}
summit_flank %<>% 
  # Note, if running FIMO with multiple motifs, this solution will not work
  # as it will count all motifs within the fimo-results without splitting by motif_id
  plyranges::mutate(n_motifs = plyranges::count_overlaps(., fimo_res), 
                    has_motif = n_motifs > 0)
```

First, to we want to determine whether E93 sensitive sites are more likely to
have E93 motifs in certain response types. Here we can see that sensitive
decreasing sites are more likely to have E93 motifs than sensitive increasing or
insensitive static sites.
```{r, fig.height=4, fig.width=5}
summit_flank %>% 
  data.frame %>% 
  dplyr::mutate(has_match = dplyr::if_else(has_motif, "Match", "No Match")) %>% 
  ggplot(aes(e93_sensitive_behavior)) +
    geom_bar(aes(fill = forcats::fct_rev(has_match)), position = "fill") +
    scale_fill_manual(values = c("Match" = "firebrick",
                                 "No Match" = "Black")) +
    labs(fill = "E93 Motif Match",
         y = "Fraction of Sites",
         x = "Response to E93 binding")
```


To investigate whether E93-sensitive sites that open/close/don't change have
different numbers of E93 motifs, we plot the fraction of sites with each number
of motifs. Here we can see that in addition to being more likely to contain an
E93 motif, sensitive decreasing sites are more likely to to contain 2 or more
matches, where 10% contain at least 2 motifs.
```{r, fig.height=5, fig.width=7}
summit_flank %>% 
  # currently, group operations are faster as data.frames, so we convert to data.frame
  data.frame %>% 
  dplyr::group_by(e93_sensitive_behavior, n_motifs) %>% 
  dplyr::count() %>% 
  dplyr::group_by(e93_sensitive_behavior) %>% 
  dplyr::mutate(frac = n/sum(n)) %>% 
  ggplot(aes(n_motifs, frac)) +
    geom_line(aes(color = e93_sensitive_behavior), size = 1) +
    labs(y = "Fraction of Sites",
         x = "Number of E93 Motifs",
         color = "Response to E93 Binding") +
    theme_bw()
```

Finally, we want to assess whether the quality of E93 motifs is different between sensitivity categories. To examine this, we need to determine which motifs are found in which peaks. We use the `plyranges::join_overlap_intersect` to return motif entries appended with peak-level metadata, like the peak id each motif is found within.
```{r}
# return position of each motif match w/ peak metadata
intersect <- summit_flank %>% 
  plyranges::join_overlap_intersect(fimo_res)
```

We use the FIMO `score` as a proxy for quality, where higher scores are better
matches to the motif. Here we examine only the best match (highest score) motif
within each peak. 

```{r, fig.height=4, fig.width=3}
intersect %>% 
  data.frame %>% 
  dplyr::group_by(id) %>% 
  # Keep only motifs w/ the highest score within a peak
  dplyr::filter(score == max(score)) %>% 
  ggplot(aes(e93_sensitive_behavior, score)) +
    geom_boxplot(aes(fill = e93_sensitive_behavior), notch = T, width = 0.5) +
    guides(fill = "none") +
    labs(x = "Response to E93",
         y = "FIMO Score") +
    theme_bw()
  
```

The [Anderson-Darling test](https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test) can be used to test differences in the distribution of FIMO scores across multiple groups. For a pairwise comparison, a [Kolmogorov-Smirnov test](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test) is commonly used instead.
```{r}
intersect %>% 
  data.frame %>% 
  dplyr::group_by(id) %>% 
  dplyr::filter(score == max(score)) %>% 
  dplyr::mutate(behavior = factor(e93_sensitive_behavior)) %>% 
  PMCMRplus::adAllPairsTest(score ~ behavior, ., p.adjust.method = "fdr")
```


### Centrality of E93 motif
Next we want to visualize whether the E93 motif has altered positioning across
the response categories. To do this we add the metadata for each nearest motif
to our peak summits. Setting `distance = TRUE` in `plyranges::join_nearest` adds
a `distance` column indicating the distance to the nearest joined region.
```{r}
summit_nearest_e93_motif <- summit_flank %>% 
  plyranges::anchor_center() %>% 
  plyranges::mutate(width = 1) %>% 
  plyranges::join_nearest(fimo_res, distance = TRUE)

```

```{r}
summit_nearest_e93_motif %>% 
  data.frame %>% 
  dplyr::filter(has_motif == TRUE) %>% 
  ggplot(aes(distance)) +
    stat_ecdf(aes(color = e93_sensitive_behavior), size = 1, pad = FALSE) +
    labs(x = "Distance to nearest E93 Motif",
         y = "Fraction of Sites",
         color = "E93 Response") +
    theme_linedraw() 
  
```
```{r}
summit_nearest_e93_motif %>% 
  data.frame %>% 
  dplyr::filter(has_motif == TRUE) %>% 
  dplyr::mutate(behavior = factor(e93_sensitive_behavior)) %>% 
  # Anderson-darling test for multiple distributions
  PMCMRplus::adAllPairsTest(distance ~ behavior, ., p.adjust.method = "fdr") 

```

```{r,include=F}
summit_nearest_e93_motif %>% 
  data.frame %>% 
  dplyr::filter(has_motif == TRUE) %>% 
  dplyr::mutate(behavior = factor(e93_sensitive_behavior)) %>% 
  # Anderson-darling test for multiple distributions
  PMCMRplus::adAllPairsTest(distance ~ behavior, ., p.adjust.method = "fdr") -> x

# Idea: show p-val signif stars on figure legend for ecdf plot?

# Below is spec code for parsing PMCMRplus output for adding to ggplot annotation
# use levels(x$model$g) to assign levels to c1 & c2 below

# for ECDF plot: consider taking plot as input, then use cowplot to grab legend, etc.
# for boxplot: grab max values from x$model$x and adjust lines from there, return annotation df
#  user will have to configure y positions
x$p.value %>% 
  data.frame %>% 
  tibble::rownames_to_column('v') %>% 
  split(.$v) %>% 
  purrr::imap(~{
    .x %>% 
      dplyr::select(-v) %>% 
      dplyr::rename_all(function(x){paste0(x, "_", .y)})
  }) %>% 
  dplyr::bind_cols() %>% 
  tidyr::pivot_longer(dplyr::everything(), names_to = "vs", values_to = "pval") %>% 
  tidyr::separate(vs, c("c1", "c2")) %>% 
  dplyr::filter(!is.na(pval)) %>% 
  dplyr::mutate(c1 = factor(c1, levels = levels(x$model$g)),
                c2 = factor(c2, levels = levels(x$model$g)))
```


# Below is in development

```{r}
# remove when done
knitr::opts_chunk$set(eval = F)
```

## AME analysis by binding category (using dreme_results as query??)

```{r ame_by_binding, cache=TRUE, cache.comments=FALSE}
ame_by_binding <- by_binding %>% 
  runAme(database = list(dreme_results)) %>% 
  dplyr::bind_rows(.id = "binding_type") 
```

Plot heatmap of results by binding type.
```{r, dependson=ame_by_binding, fig.height=4, fig.width=10}
ame_by_binding %>% 
  ame_plot_heatmap(group = binding_type)
```

## Denovo motif similarity by binding
```{r dreme_by_binding, eval=F}
dreme_by_binding <- by_binding %>% 
  runDreme("shuffle") %>% 
  dplyr::bind_rows(.id = "binding_type")
```

```{r}
# The above code chunk takes a long time to run.
# dremeR is packaged with the results of this run in the "example_dreme_by_binding" dataset
# which can be loaded as follows:
data("example_dreme_by_binding", package = "dremeR")
dreme_by_binding <- example_dreme_by_binding
```

Rename the motifs to indicate the binding category they were discovered in.
```{r}
dreme_by_binding_renamed <- dreme_by_binding %>% 
  dplyr::mutate(id = paste(binding_type, seq, sep = "_")) %>% 
  # update_motifs updates the information in the special `motif` column
  update_motifs()
```


```{r, fig.height=7, fig.width=10}
cols <- colorRampPalette(c("white", "dodgerblue4"))(255)

anno.df <- dreme_by_binding_renamed %>% 
  dplyr::select(id, binding_type) %>% 
  tibble::column_to_rownames("id")

dreme_by_binding_renamed %>% 
  {universalmotif::compare_motifs(.$motif, method = "PCC")} %>% 
  pheatmap::pheatmap(color = cols, 
                     breaks = seq(0, 1, by = 1/255), 
                     annotation_col = anno.df, 
                     show_colnames = FALSE) 
```

